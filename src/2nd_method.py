# -*- coding: utf-8 -*-
"""2nd-method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xSDBJh9pJY1mKB_qi0ycmJgSbHL39n6n
"""

def fact(n):
  """Calculate the factorial of a given number n

  Parameters
  ----------
  n: Int

  Returns
  -------
  factorial: Int
  """
  if n == 0:
    return 1

  f = 1

  for i in range(1, n+1):
    f = f * i

  return f


def calculate_nck(n, k):
  """Calculate the total number of combinations of a given number n, k

  Parameters
  ----------
  n: Int

  k: Int

  Returns
  -------
  number_of_combinations: Int
  """
  if n == 0: 
    return 0

  return int(fact(n) / (fact(k) * fact(n-k)))

"""This section is for testing the utility functions
  
  The functions are tested:
  - fact
  - calculate_nck
"""
assert fact(4) == 24 
assert fact(1) == 1 
assert fact(0) == 1 

assert calculate_nck(5, 3) == 10
assert calculate_nck(5, 1) == 5
assert calculate_nck(5, 4) == 5
assert calculate_nck(0, 4) == 0

print("---------------------")
print("All tests are passed!")

def generate_combination(n, k, index):
  """Generate a combination of a given number n, k at given index

  Parameters
  ----------
  n: Int
  k: Int
  index: Int

  Returns
  -------
  combination: list(Int)
  """
  combination = []

  nck = calculate_nck(n, k)

  # m can be uniquely represented by a sum of binomials:
  #   (c_1 k) + (c_2 k-1) + ... + (c_k 1)
  # where 0 <= c_i < n.
  m = nck-1-index

  # guess cannot exceed n-1, otherwise (guess k) exceeds the index range.
  guess = n-1

  for i in range(k):
    ri = k-i
    take = calculate_nck(guess, ri)
    while (take > m):
      guess = guess-1
      take = calculate_nck(guess, ri)
    
    m = m-take
    combination.append(n-guess)

  return combination

"""This section is for testing the main function
  
  The functions are tested:
  - generate_combination
"""
n = 5
k = 3

combinations = []
nck = calculate_nck(n, k)

# Generate all possible combinations
for i in range(nck):
  combinations.append(generate_combination(n, k, i))

# Print all combinations
for c in combinations:
  print(c)

from joblib import Parallel, delayed
import multiprocessing

PRINT = True

n = 5
k = 3

nck     = calculate_nck(n, k)
inputs  = range(nck)
outputs = []

num_cores = multiprocessing.cpu_count()

def process_input(i):
    return generate_combination(n, k, i)
     
# Generate combinations in parallel
outputs = Parallel(n_jobs=num_cores)(delayed(process_input)(i) for i in inputs)

print("number of cores:        ", num_cores)
print("number or combinations: ", nck)
print("------------------------------")

# Print all combinations
for c in outputs:
  print(c)

print("------------------------------")
print("DONE!")